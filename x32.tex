\chapter{X32 Programming Model\label{x32}}

\section{Parameter Passing}
When a value of pointer type is returned or passed in a register, bits 32
to 63 shall be zero\footnote{\xARCH zero-extends 32-bit result to 64-bit
in the destination general-purpose register, hence the supplier side and
the consumer side of those values don't need to explicitly zero-extend
32-bit pointer values to 64bit.}.

\section{Address Space}

\xARCH X32 binaries reside in the lower 32bits of the 64bit virtual
address space and all addresses are 32bits in size.  They should conform
to \textindex{small code model} or
\textindex{small position independent code model} (\textindex{PIC})
described in Section \ref{models}.

\section{Kernel Support}
Kernel should limit stack and addresses returned from system calls
bewteen $0x00000000$ to $0xffffffff$.

\section{Coding Examples}

Although X32 binaries run in the 64bit mode, not all 64bit instructions
are supported. This section discusses example code sequences for
fundamental operations which are different from the 64bit mode.

\subsection{Indirect Branch}

Since indirect branch via memory loads a 64bit address at the memory
location, it is not supported in X32.  Indirect branch via register
should be used instead.

\begin{table}[H]
\Hrule
\caption{Indirect Branch}
\begin{center}
\code{
\begin{tabular}{ll|ll}
\multicolumn{2}{c}{LP64} & \multicolumn{2}{c}{X32} \\
\hline
call & *\%rax          & call & *\%rax \\
\hline
call & *func\_p(\%rip) & movl & func\_p(\%rip), \%eax \\
     &                 & call & *\%rax \\
\hline
call & *func\_p        & movl & func\_p, \%eax \\
     &                 & call & *\%rax \\
\hline
jmp  & *\%rax          & jmp  & *\%rax \\
\hline
jmp  & *func\_p(\%rip) & movl & func\_p(\%rip), \%eax \\
     &                 & jmp  & *\%rax \\
\hline
jmp  & *func\_p        & movl & func\_p, \%eax \\
     &                 & jmp  & *\%rax \\
\end{tabular}
}
\end{center}
\Hrule
\end{table}
