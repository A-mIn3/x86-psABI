\chapter{X32 Programming Model\label{x32}}

\section{Parameter Passing}
When a value of pointer type is returned or passed in a register, bits 32
to 63 shall be zero.

\section{Address Space}

\xARCH X32 binaries reside in the lower 32bits of the 64bit virtual
address space and all addresses are 32bits in size.  They should conform
to \textindex{small code model} or
\textindex{small position independent code model} (\textindex{PIC})
described in Section \ref{models}.

\section{Thread-Local Storage Support}

X32 Thread-Local Storage (TLS) support is based on LP64 TLS
implementation with some modifcations.

\subsection{Global Thread-Local Variable}

For a global thread-local variable x:

\begin{verbatim}
extern __thread int x;
\end{verbatim}

\begin{description}
\item[\textindex{General Dynamic Model}]
  Load address of \code{x} into \reg{rax}/\reg{eax}

\begin{table}[H]
\Hrule
\caption{General Dynamic Model Code Sequence}
\begin{center}
\code\small{
\begin{tabular}{lll|lll}
\multicolumn{3}{c}{LP64} & \multicolumn{3}{c}{X32} \\
\hline
0x00 & .byte & 0x66			& 0x00 & leaq  & x@tlsgd(\%rip),\%rdi \\
0x01 & leaq  & x@tlsgd(\%rip),\%rdi	& 0x07 & .word & 0x6666 \\
0x08 & .word & 0x6666			& 0x09 & rex64 & \\
0x0a & rex64 &				& 0x0b & call  & \_\_tls\_get\_addr@plt \\
0x0b & call  & \_\_tls\_get\_addr@plt	&      &       & \\
\end{tabular}
}
\end{center}
\Hrule
\end{table}

\item[\textindex{Initial Exec Model}]
  Load address of \code{x} into \reg{rax}/\reg{eax}

\begin{table}[H]
\Hrule
\caption{Initial Exec Model Code Sequence}
\begin{center}
\code\small{
\begin{tabular}{lll|lll}
\multicolumn{3}{c}{LP64} & \multicolumn{3}{c}{X32} \\
\hline
0x01 & movq & \%fs:0,\%rax		& 0x01 & movl & \%fs:0,\%eax \\
0x09 & addq & x@gottpoff(\%rip),\%rax	& 0x08 & addl & x@gottpoff(\%rip),\%eax \\
\end{tabular}
}
\end{center}
\Hrule
\end{table}

\item[\textindex{Initial Exec Model, II}]
  Load value of \code{x} into \reg{edi}

\begin{table}[H]
\Hrule
\caption{Initial Exec Model Code Sequence, II}
\begin{center}
\code\small{
\begin{tabular}{lll|lll}
\multicolumn{3}{c}{LP64} & \multicolumn{3}{c}{X32} \\
\hline
0x01 & movq & x@gottpoff(\%rip),\%rax	& 0x01 & movq & x@gottpoff(\%rip),\%rax \\
0x07 & movl & \%fs:(\%rax),\%edi	& 0x08 & movl & \%fs:(\%rax),\%edi \\
\end{tabular}
}
\end{center}
\Hrule
\end{table}

\end{description}

\section{Kernel Support}
Kernel should limit stack and addresses returned from system calls
bewteen $0x00000000$ to $0xffffffff$.

\section{Coding Examples}

Although X32 binaries run in the 64bit mode, not all 64bit instructions
are supported. This section discusses example code sequences for
fundamental operations which are different from the 64bit mode.

\subsection{Indirect Branch}

Since indirect branch via memory loads a 64bit address at the memory
location, it is not supported in X32.  Indirect branch via register
should be used instead.

\begin{table}[H]
\Hrule
\caption{Indirect Branch}
\begin{center}
\code{
\begin{tabular}{ll|ll}
\multicolumn{2}{c}{LP64} & \multicolumn{2}{c}{X32} \\
\hline
call & *\%rax          & call & *\%rax \\
\hline
call & *func\_p(\%rip) & movl & func\_p(\%rip), \%eax \\
     &                 & call & *\%rax \\
\hline
call & *func\_p        & movl & func\_p, \%eax \\
     &                 & call & *\%rax \\
\hline
jmp  & *\%rax          & jmp  & *\%rax \\
\hline
jmp  & *func\_p(\%rip) & movl & func\_p(\%rip), \%eax \\
     &                 & jmp  & *\%rax \\
\hline
jmp  & *func\_p        & movl & func\_p, \%eax \\
     &                 & jmp  & *\%rax \\
\end{tabular}
}
\end{center}
\Hrule
\end{table}
